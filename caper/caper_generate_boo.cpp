#include "caper_ast.hpp"
#include "caper_error.hpp"
#include "caper_generate_boo.hpp"
#include "caper_format.hpp"
#include "caper_stencil.hpp"
#include "caper_finder.hpp"
#include <algorithm>
#include <boost/tuple/tuple.hpp>
#include <boost/tuple/tuple_comparison.hpp>

struct semantic_action_entry {
    std::string                     name;
    std::vector< std::string >      args;

    bool operator<( const semantic_action_entry& x ) const {
        if (name < x.name) { return true; }
        if (x.name < name) { return false; }
        return args < x.args;
    }
};

void generate_boo(
    const std::string&                  src_filename,
    std::ostream&                       os,
    const GenerateOptions&              options,
    const std::map<std::string, Type>&  terminal_types,
    const std::map<std::string, Type>&  nonterminal_types,
    const std::vector<std::string>&     tokens,
    const action_map_type&              actions,
    const tgt::parsing_table&           table) {

    if (options.allow_ebnf) {
        throw unsupported_feature("Boo", "EBNF");
    }

    // notice / URL
    stencil(
        os, R"(
// This file was automatically generated by Caper.
// (http://jonigata.github.io/caper/caper.html)

namespace ${namespace_name}

import System.Collections.Generic

)",
        {"namespace_name", options.namespace_name});

    // enum Token
    if (!options.external_token) {
        // token enumeration
        //os << options.access_modifier << "enum Token:\n";
        //for (size_t i = 0 ; i < tokens.size() ; i++) {
        //    os << "  " << options.token_prefix << tokens[i] << "\n";
        //}
        //os << "\n";
        stencil(
            os, R"(
enum Token:
$${tokens}

)",
            {"tokens", [&](std::ostream& os) {
                for (const auto& token: tokens) {
                    stencil(
                        os, R"(
  ${prefix}${token}
)",
                        {"prefix", options.token_prefix},
                        {"token", token});
                }
            }
        });
    }

    // ISemanticAction interface
    std::set< semantic_action_entry > ss;

    for (action_map_type::const_iterator it = actions.begin(); it != actions.end(); ++it) {
        const tgt::parsing_table::rule_type& rule = it->first;
        const SemanticAction& sa = it->second;

        semantic_action_entry sae;
        sae.name = sa.name;

        // 1st argument = out parameter
        sae.args.push_back( (*nonterminal_types.find( rule.left().name() )).second.name );

        for (size_t l = 0; l < sa.args.size(); l++) {
            sae.args.push_back( sa.args[l].type.name );
        }

        ss.insert( sae );
    }

    std::unordered_set<std::string> types;
    for (const auto& x: terminal_types) {
        if (x.second.name != "") {
            types.insert(x.second.name);
        }
    }

    for (const auto& x: nonterminal_types) {
        if (x.second.name != "") {
            types.insert(x.second.name);
        }
    }

    os << options.access_modifier << "interface ISemanticAction:\n";
    os << "  def syntax_error() as void\n";
    os << "  def stack_overflow() as void\n";

    /*
       for( std::unordered_set< std::string >::const_iterator i = types.begin();
       i != types.end();
       ++i ) {
       os << "		" << "void upcast( out object x, " << (*i) << " y );\n";
       }

       for( std::unordered_set< std::string >::const_iterator i = types.begin();
       i != types.end();
       ++i ) {
       os << "		" << "void downcast( out " << (*i) << " x, object y );\n";
       }*/
    os << "\n";
        
    std::unordered_set< std::string > methods;

    for (std::set< semantic_action_entry >::const_iterator it = ss.begin(); it != ss.end(); ++it) {
        std::stringstream methodstream;
        methodstream << "  def " << (*it).name << "(ref ";
        bool first = true;
        for (size_t l = 0; l < (*it).args.size(); l++) {
            if (first) { first = false; } else { methodstream << ", "; }
            methodstream << "arg" << l << " as " << ((*it).args[l]);
        }
        methodstream << ") as void\n";
        methods.insert(methodstream.str());
    }

    for (std::unordered_set<std::string>::const_iterator it = methods.begin(); it != methods.end(); ++it)
        os << *it;

    os << "\n";

    // parser class
    os << options.access_modifier << "class Parser ():\n"
       // stack_frame clas
       << "  private class stack_frame ():\n"
       << "    public state as state_type\n"
       << "    public gotof as gotof_type\n"
       << "    public value as object\n\n"
       << "    public def constructor(s as state_type, g as gotof_type, v as object):\n"
       << "      state = s\n"
       << "      gotof = g\n"
       << "      value = v\n"
       << "\n"
       // Stack class
       << "  private class Stack ():\n"
       << "    private stack = List[of stack_frame]()\n"
       << "    private tmp = List[of stack_frame]()\n"
       << "    private gap as int\n"
       << "\n"
       << "    public def constructor():\n"
       << "      self.gap = 0\n"
       << "\n"
       << "    public def reset_tmp():\n"
       << "      self.gap = self.stack.Count\n"
       << "      self.tmp.Clear()\n"
       << "\n"
       << "    public def commit_tmp():\n"
       << "      size = self.gap + self.tmp.Count\n"
       << "      self.stack.Capacity = size if size > self.stack.Capacity\n"
       << "      self.stack.RemoveRange(self.gap, self.stack.Count - self.gap)\n"
       << "      self.stack.AddRange(self.tmp)\n"
       << "\n"
       << "    public def push(f as stack_frame) as bool:\n"
       << "      self.tmp.Add(f)\n"
       << "      return true\n"
       << "\n"
       << "    public def pop(n as int):\n"
       << "      if self.tmp.Count < n:\n"
       << "        n -= self.tmp.Count\n"
       << "        self.tmp.Clear()\n"
       << "        self.gap -= n\n"
       << "      else:\n"
       << "        self.tmp.RemoveRange(self.tmp.Count - n, n)\n"
       << "\n"
       << "    public def top() as stack_frame:\n"
       << "      if self.tmp.Count != 0:\n"
       << "        return self.tmp[self.tmp.Count - 1]\n"
       << "      else:\n"
       << "        return self.stack[self.gap - 1]\n"
       << "\n"
       << "    public def my_get_arg(b as int, i as int) as stack_frame:\n"
       << "      n = self.tmp.Count\n"
       << "      if b - i <= n:\n"
       << "        return self.tmp[n - (b - i)]\n"
       << "      else:\n"
       << "        return self.stack[self.gap - (b - n) + i]\n"
       << "\n"
       << "    public def clear():\n"
       << "      self.stack.Clear()\n"
       << "\n"
       << "  // class Stack\n\n"
       // delegate
       << "  private callable state_type(token as Token, value as object) as bool\n"
       << "  private callable gotof_type(i as int, value as object) as bool\n"
       << "\n"
       // constructor
       << "  public def constructor(sa as ISemanticAction):\n"
       << "    self.stack = Stack()\n"
       << "    self.sa = sa\n"
       << "    self.reset()\n"
       << "\n\n"
       // public member
       << "  public def reset():\n"
       << "    self.error = false\n"
       << "    self.accepted = false\n"
       << "    self.clear_stack()\n"
       << "    self.reset_tmp_stack()\n"
       << "    if self.push_stack("
       << "self.state_" << table.first_state() << ", "
       << "self.gotof_" << table.first_state()
       << ", " << "object()):\n"
       << "      self.commit_tmp_stack()\n"
       << "    else:\n"
       << "      self.sa.stack_overflow()\n"
       << "      self.error = true\n"
       << "\n"
       << "  public def post(token as Token, value as object) as bool:\n"
       << "    System.Diagnostics.Debug.Assert(not self.error)\n"
       << "    self.reset_tmp_stack()\n"
       << "    while stack_top().state(token, value):\n"
       << "      pass\n"
       << "    unless self.error:\n"
       << "      self.commit_tmp_stack()\n"
       << "    return self.accepted\n"
       << "\n"
       << "  public def accept(ref v as object) as bool:\n"
       << "    System.Diagnostics.Debug.Assert(self.accepted)\n"
       << "    if self.error:\n"
       << "      v = object()\n"
       << "      return false\n"
       << "    v = self.accepted_value\n"
       << "    return true\n"
       << "\n"
       << "  public def Error() as bool:\n"
       << "    return self.error\n"
       << "\n"
       // private member
       << "  private sa as ISemanticAction\n"
       << "  private stack as Stack\n"
       << "  private accepted as bool\n"
       << "  private error as bool\n"
       << "  private accepted_value as object\n"
       << "\n"
       << "  private def push_stack(s as state_type, g as gotof_type, v as object) as bool:\n"
       << "    f = self.stack.push(stack_frame(s, g, v))\n"
       << "    System.Diagnostics.Debug.Assert(not self.error)\n"
       << "    unless f:\n"
       << "      self.error = true\n"
       << "      self.sa.stack_overflow()\n"
       << "    return f\n"
       << "\n"
       << "  private def pop_stack(n as int):\n"
       << "    self.stack.pop(n)\n"
       << "\n"
       << "  private def stack_top() as stack_frame:\n"
       << "    return self.stack.top()\n"
       << "\n"
       << "  private def my_get_arg(b as int, i as int) as object:\n"
       << "    return stack.my_get_arg(b, i).value\n"
       << "\n"
       << "  private def clear_stack():\n"
       << "    self.stack.clear()\n"
       << "\n"
       << "  private def reset_tmp_stack():\n"
       << "    self.stack.reset_tmp()\n"
       << "\n"
       << "  private def commit_tmp_stack():\n"
       << "    self.stack.commit_tmp()\n"
       << "\n"
       ;
        
    // states handler
    for (tgt::parsing_table::states_type::const_iterator i = table.states().begin(); i != table.states().end(); ++i) {
        const tgt::parsing_table::state& s = *i;

        // gotof header
        os << "  def gotof_" << s.no << "(nonterminal_index as int, v as object) as bool:\n";
        // gotof dispatcher
        std::stringstream ss;
        //ss << "			switch(nonterminal_index)\n"
        //   << "			{\n";
        bool output_switch = false;
        std::set<size_t> generated;
        bool first = true;
        for (const auto& rule: table.get_grammar()) {
            size_t nonterminal_index = std::distance(
                nonterminal_types.begin(),
                nonterminal_types.find( rule.left().name() ) );

            if (generated.find( nonterminal_index ) != generated.end()) {
                continue;
            }

            tgt::parsing_table::state::goto_table_type::const_iterator k =
                (*i).goto_table.find(rule.left());

            if (k != (*i).goto_table.end()) {
                if (first) {
                    ss << "    if nonterminal_index == " << nonterminal_index << ":\n";
                    first = false;
                } else {
                    ss << "    elif nonterminal_index == " << nonterminal_index << ":\n";
                }
                ss << "      return push_stack(self.state_" << (*k).second
                    << ", self.gotof_" << (*k).second
                    << ", v)\n";
                output_switch = true;
                generated.insert( nonterminal_index );
            }
        }
        ss << "    else:\n"
           << "      System.Diagnostics.Debug.Assert(false)\n"
           << "      return false\n"
           << "\n";
        if (output_switch) {
            os << ss.str();
        } else {
            os << "    System.Diagnostics.Debug.Assert(false)\n"
               << "    return true\n";
        }
        // gotof footer
        os << "\n";

        // state header
        os << "  def state_" << s.no << "(token as Token, value as object) as bool:\n";

        // dispatcher header
        //os << "			switch(token)\n"
        //   << "			{\n";

        // action table
        first = true;
        int ridx = 0;
        for (tgt::parsing_table::state::action_table_type::const_iterator j = s.action_table.begin(); j != s.action_table.end(); ++j) {
            // action header 
            if (first) {
                os << "    if token == Token." << options.token_prefix << tokens[(*j).first] << ":\n";
                first = false;
            } else {
                os << "    elif token == Token." << options.token_prefix << tokens[(*j).first] << ":\n";
            }
            // action
            const tgt::parsing_table::action* a = &(*j).second;
            switch( a->type ) {
            case zw::gr::action_shift:
                os << "      // shift\n"
                   << "      push_stack( "
                   << "self.state_" << a->dest_index << ", "
                   << "self.gotof_" << a->dest_index << ", "
                   << "value)\n"
                   << "      return false;\n";
                break;
            case zw::gr::action_reduce:
                os << "      // reduce\n";
                {
                    size_t base = a->rule.right().size();

                    const tgt::parsing_table::rule_type& rule = a->rule;
                    action_map_type::const_iterator k = actions.find( rule );

                    size_t nonterminal_index = std::distance(
                        nonterminal_types.begin(),
                        nonterminal_types.find( rule.left().name() ) );

                    if( k != actions.end() ) {
                        const SemanticAction& sa = (*k).second;

                        //os << "				{\n";
                        // automatic argument conversion
                        for( size_t l = 0 ; l < sa.args.size() ; l++ ) {
                            const SemanticAction::Argument& arg = sa.args[l];
                            os << "      arg" << l
                               << " = my_get_arg(" << base
                               << ", " << arg.source_index << ") cast " << arg.type.name << "\n";
                        }

                        // semantic action
                        os << "      r" << ridx << " as " << (*nonterminal_types.find( rule.left().name() )).second.name << "\n";
                        os << "      self.sa." << sa.name << "(r" << ridx;
                        for (size_t l = 0; l < sa.args.size(); l++) {
                            os << ", arg" << l;
                        }
                        os << ")\n";

                        // automatic return value conversion
                        os << "      v = r" << ridx << " cast object\n";
                        os << "      pop_stack(" << base << ")\n";
                        os << "      return stack_top().gotof(" << nonterminal_index << ", v)\n";
                    } else {
                        os << "      // run_semantic_action();\n";
                        os << "      pop_stack(" << base << ")\n";
                        os << "      return stack_top().gotof(" << nonterminal_index << ", object())\n";
                    }
                }
                break;
            case zw::gr::action_accept:
                os << "      // accept\n";
                os << "      // run_semantic_action();\n";
                os << "      self.accepted = true\n";
                os << "      self.accepted_value = my_get_arg(1, 0)\n"; // implicit root
                os << "      return false\n";
                break;
            case zw::gr::action_error:
                os << "      self.sa.syntax_error()\n";
                os << "      self.error = true\n"; 
                os << "      return false\n";
                break;
            }

            // action footer
            ++ridx;
        }

        // dispatcher footer
        os << "    else:\n";
        os << "      self.sa.syntax_error()\n";
        os << "      self.error = true\n";
        os << "      return false\n";
        // state footer
        os << "\n";
    }

    os << "// class Parser\n\n";
        
    // namespace footer
    //os << "} // namespace " << options.namespace_name;

    // once footer
}

