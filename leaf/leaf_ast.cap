base = Node;

module-header = @{
namespace leaf {

}@

module-footer = @{
} // namespace leaf

}@

class-footer = @{
    void encode( EncodeContext&, bool, Value& );
    void entype( EntypeContext&, bool, type_t );

}@

atom = bool, char, int, symbol_t, type_t, symmap_t;

type Module = TopElems(topelems);

type TopElems = TopElem*(v);
type TopElem = Require | TopLevelFunDecl | TopLevelFunDef;

type Require = Identifier(name), Module(module);
type TopLevelFunDecl = FunDecl(fundecl);
type TopLevelFunDef = FunDef(fundef);

type FunSig = Identifier(name), FormalArgs(fargs), Types(result_type);
type FormalArgs = FormalArg*(v);
type FormalArg = Identifier(name), TypeRef(t);

type Block = Statements(statements);

type Statements = Statement*(v);
type Statement = FunDecl | FunDef | VarDecl | IfThenElse | MultiExpr;

type FunDecl = FunSig(sig);
type FunDef = FunSig(sig), Block(body), symmap_t(freevars);

type VarDecl = VarDeclElems(varelems), MultiExpr(value);
type VarDeclElem = VarDeclElems | VarDeclIdentifier;
type VarDeclElems = VarDeclElem*(v);
type VarDeclIdentifier = Identifier(name), TypeRef(t);

type IfThenElse = Expr(cond), Block(iftrue), Block(iffalse);

type MultiExpr = Expr*(v);

type Expr = LogicalOr;

type LogicalOr = LogicalAnd*(v);

type LogicalAnd = Equality*(v);

type Equality = Relational | EqualityEq | EqualityNe;

type Relational = Additive
	 			| RelationalLt | RelationalGt
				| RelationalLe | RelationalGe;

type EqualityEq = Equality(lhs), Relational(rhs);
type EqualityNe = Equality(lhs), Relational(rhs);

type RelationalLt = Relational(lhs), Additive(rhs);
type RelationalGt = Relational(lhs), Additive(rhs);
type RelationalLe = Relational(lhs), Additive(rhs);
type RelationalGe = Relational(lhs), Additive(rhs);

type Additive = Multiplicative | AddExpr | SubExpr;
type AddExpr = Additive(lhs), Multiplicative(rhs);
type SubExpr = Additive(lhs), Multiplicative(rhs);

type Multiplicative = CastExpr | MulExpr | DivExpr;
type MulExpr = Multiplicative(lhs), CastExpr(rhs);
type DivExpr = Multiplicative(lhs), CastExpr(rhs);

type CastExpr = Cast | PrimExpr;
type Cast = PrimExpr(expr), TypeRef(t);

type PrimExpr = LiteralBoolean | LiteralInteger | LiteralChar
              | VarRef | Parenthized | FunCall | Lambda;
type LiteralBoolean = bool(value);
type LiteralInteger = int(value);
type LiteralChar = char(value);
type VarRef = Identifier(name);
type Parenthized = MultiExpr(exprs);
type FunCall = Identifier(func), ActualArgs(aargs);
type Lambda = symbol_t(name),
			  FormalArgs(fargs), Types(result_type), Block(body),
			  symmap_t(freevars);

type ActualArgs = ActualArg*(v);
type ActualArg = Expr(expr);

type Types = TypeRef*(v);
type TypeRef = type_t(t);

type Identifier = symbol_t(s);
